import CryptoJS from "crypto-js";
import * as crypto from "crypto";
import errorHandler from "../helpers/errorHandler";
import * as interfaces from "../models/interfaces";
import * as appSettings from "../config/appSettings.json";
import { FileEncoding } from "../models/utilityEnums";

export default class CryptoUtil {
  private static BASE_64: BufferEncoding = FileEncoding.BASE64; // base64 encoding as buffer encoding

  /**
   * Generates a cryptographically secure initialization vector of the specified length as a base64 string.
   * @param length The length of the IV to generate in bytes. Defaults to the default IV length.
   * @returns A base64 string containing a secure IV of the specified length.
   * @throws {Error} If the length is less than or equal to zero.
   * @throws {Error} If an error occurs during IV generation.
   */
  public static generateIvAsBase64(
    length: number = appSettings.PARAMETER_LENGTHS.IV_LENGTH
  ): string {
    if (length <= 0) throw new Error("IV length must be greater than zero.");
    try {
      return crypto.randomBytes(length).toString(this.BASE_64);
    } catch (error) {
      errorHandler.logGeneralError(
        error,
        "generateIv",
        `Failed to generate IV of length ${length}`
      );
      throw error;
    }
  }

  /**
   * Generates a cryptographically secure initialization vector of the specified length as a Buffer.
   * @param length The length of the IV to generate in bytes. Defaults to the default IV length.
   * @returns A Buffer containing a secure IV of the specified length.
   * @throws {Error} If the length is less than or equal to zero.
   * @throws {Error} If an error occurs during IV generation.
   */
  public static generateIvAsBuffer(
    length: number = appSettings.PARAMETER_LENGTHS.IV_LENGTH
  ): Buffer {
    if (length <= 0) throw new Error("IV length must be greater than zero.");
    try {
      return crypto.randomBytes(length);
    } catch (error) {
      errorHandler.logGeneralError(
        error,
        "generateIvAsBuffer",
        `Failed to generate IV of length ${length}`
      );
      throw error;
    }
  }

  /**
   * Generates a cryptographically secure random salt of the specified length as a base64 string.
   * @param length The length of the salt to generate in bytes. Defaults to the default salt length.
   * @returns A base64 string containing a secure salt of the specified length.
   * @throws {Error} If an error occurs during salt generation.
   */
  public static generateSalt(
    length: number = appSettings.PARAMETER_LENGTHS.SALT_LENGTH
  ): string {
    if (length <= 0) throw new Error("Salt length must be greater than zero.");
    try {
      return crypto.randomBytes(length).toString(this.BASE_64);
    } catch (error) {
      errorHandler.logGeneralError(
        error,
        "generateSalt",
        `Failed to generate salt of length ${length}`
      );
      throw error;
    }
  }

  /**
   * Generates a cryptographically secure random key of the specified length as a base64 string.
   * @param length The length of the key to generate in bytes. Defaults to the default key length.
   * @returns A base64 string containing a secure key of the specified length.
   * @throws {Error} If an error occurs during key generation.
   */
  public static generateKey(
    length: number = appSettings.PARAMETER_LENGTHS.KEY_LENGTH
  ): string {
    try {
      // Generate a cryptographically secure random key
      return crypto.randomBytes(length).toString(this.BASE_64);
    } catch (error) {
      errorHandler.logGeneralError(
        error,
        "generateKey",
        "Failed to generate key"
      );
      throw error;
    }
  }

  /**
   * Derives a key from the given secret key and salt using PBKDF2.
   *
   * @param secretKey - The secret key to use for derivation.
   * @param salt - The salt to use for derivation.
   * @returns A derived key as a CryptoJS WordArray.
   */
  public static deriveKey(
    secretKey: string,
    salt: string
  ): CryptoJS.lib.WordArray {
    try {
      return CryptoJS.PBKDF2(secretKey, CryptoJS.enc.Base64.parse(salt), {
        keySize: 256 / 32,
        iterations: appSettings.KEY_DERIVATION.iterations,
      });
    } catch (error) {
      errorHandler.logGeneralError(error, "deriveKey", "Failed to derive key.");
      throw error;
    }
  }

  /**
   * Generates a message authentication code (MAC) using the HMAC-SHA256 algorithm
   * given the salt, initialization vector, ciphertext, and key.
   *
   * The MAC is generated by concatenating the salt, IV, and ciphertext with colons
   * and then hashing the result using the given key with HMAC-SHA256.
   *
   * @param salt - The salt used for encryption.
   * @param iv - The initialization vector used for encryption.
   * @param cipherText - The encrypted data.
   * @param key - The key used for encryption.
   * @returns The generated MAC as a string.
   */
  public static generateMac(
    salt: string,
    iv: string,
    cipherText: string,
    key: CryptoJS.lib.WordArray
  ): string {
    try {
      return CryptoJS.HmacSHA256(
        `${salt}:${iv}:${cipherText}`,
        key.toString(CryptoJS.enc.Base64)
      ).toString();
    } catch (error) {
      errorHandler.logGeneralError(
        error,
        "generateMac",
        "Failed to generate MAC."
      );
      throw error;
    }
  }

  /**
   * Validates the parsed data to ensure all required properties are present.
   *
   * The required properties are salt, iv, cipherText, and mac.
   *
   * @param parsedData - The parsed data to validate.
   * @throws Error - If any of the required properties are missing.
   */
  public static validateParsedData(
    parsedData: interfaces.EncryptionParams
  ): void {
    try {
      const { salt, iv, cipherText, mac } = parsedData;
      if (!salt || !iv || !cipherText || !mac) {
        errorHandler.logAndThrowError(
          "Missing required properties in encrypted data."
        );
      }
    } catch (error) {
      errorHandler.logGeneralError(
        error,
        "validateParsedData",
        "Failed to validate parsed data."
      );
      throw error;
    }
  }
}
